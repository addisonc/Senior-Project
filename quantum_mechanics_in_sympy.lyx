#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1.5in
\topmargin 1.5in
\rightmargin 1.5in
\bottommargin 1.5in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Quantum Mechanics, Quantum Computation, and the Density Operator in Sympy
\end_layout

\begin_layout Author
Addison Cugini
\end_layout

\begin_layout Date
06/05/2011
\end_layout

\begin_layout Abstract
Because aspects of quantum mechanics are both difficult to understand and
 difficult algebraically, there is a need for software which symbolically
 simulates quantum mechanical phenomena.
 To further this goal, code has been added to an open-source computer algebra
 system call Sympy which models the abstraction of Dirac notation and the
 density operator.
 Additionally, a quantum computer simulation has been built using this abstracti
on.
 This paper shall discuss the code that has been added as well as any relevant
 physics that is important to the understanding of the code.
 In particular, we shall focus on understanding the density operator of
 statistical quantum mechanics using Sympy's density matrices as a guide.
\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Standard
Students unfamiliar with quantum mechanics oftentimes find themselves getting
 lost in arithmetic and algebraic details and consequently have a hard time
 grasping the fundamental concepts behind the theory.
 For this reason, there is a need for software which simplifies the learning
 process by doing much of the meticulous algebra for the user.
 There is no doubt that a symbolic engine would be highly useful for attaining
 this goal.
 With this in mind, we have added code to an open source project called
 Sympy, which extends the Python programming language to handle symbolic
 computation.
 The code we have added includes both a base layer which abstracts in code
 the Dirac notation, as well as specific sub-modules which model certain
 quantum systems.
\end_layout

\begin_layout Standard
This paper shall discuss the quantum mechanics simulation code that has
 been added to the Computer Algebra System (CAS) Sympy during the 2010 Google
 Summer of Code and during my senior project.
 This shall include a general introduction to the syntax and data structures
 key to Sympy as well as a look at how this was used to implement Dirac
 notation.
 We shall then look at a notion of Dirac Notation was used to simulate the
 gate model of quantum computation.
 Finally, we shall discuss the density operator of statistical quantum mechanics
 and how we recently extended the code to model its use.
\end_layout

\begin_layout Part
Python and Sympy
\end_layout

\begin_layout Standard
Python is a high level programming language that aims to be easy to use
 and easy to learn.
 To further this aim, the language supports multiple programming paradigms
 including functional, imperative and object oriented; both functions and
 classes are considered first class citizens.
 In contrast to Perl's credo 
\begin_inset Quotes eld
\end_inset

There is more than one way to do it
\begin_inset Quotes erd
\end_inset

, The Zen of Python asserts 
\begin_inset Quotes eld
\end_inset

There should be one--and preferably only one--obvious way to do it
\begin_inset Quotes erd
\end_inset

.
 In this way, Python aims to be easy to read and learn by providing only
 one obvious way to solve a particular task (Perl is infamous for requiring
 people to learn too many programming techniques).
\end_layout

\begin_layout Standard
Keeping with its simplicity, Python is an interactive interpreted language,
 which means that code does not need to be compiled and can be typed directly
 into an interpreter.
 In addition to the basic command line Python interpreter, a third-party
 open-source package called iPython adds shell functionality.
 This includes the such basic functionality as changing directories, running
 files, listing files in a directory, as well as more advanced features
 such as tab completion and a history of commands run.
 The most bleeding edge versions of iPython allow for rendering of the common
 typesetting languages LaTex and HTML.
 These features create an environment that makes it easy to test code.
 All code examples contain in this document were created using this version
 of iPython.
\end_layout

\begin_layout Standard
Python has several modules which provide functionality that is useful for
 mathematics and scientific computing.
 Fast numerical algorithms on matrices and arrays are supplied by the Scipy
 and Numpy modules, which have run times nearly as fast as hand-written
 C/C++ code.
 These modules are competitors to Matlab with the advantage of using a much
 more manageable programming language.
 Sympy is a computer algebra system which hopes to compete with well established
 symbolic engines such as Mathematica, Maple or Maxima.
 Features include support for algebraic simplifications, ODE solving, integratio
n (the Risch Algorithm is partially implemented), linear algebra and more.
 
\end_layout

\begin_layout Standard
What follows is a short demonstration of the general symbolic capabilities
 of Sympy rendered in the bleeding edge version of iPython.
 All code was attained by screen-grabbing the input-output of the iPython
 notebook; there is no magic and no trickery, the notebook actually renders
 LaTeX code.
 This example is done so that the reader can understand the clear syntax
 Sympy provides.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/generalSympy.png
	width 6in

\end_inset


\end_layout

\begin_layout Subsection
Data Structures in Sympy
\end_layout

\begin_layout Standard
Sympy's symbolic engine takes advantage of object orientation (inheritance
 in particular) to create an easily extensible code base.
 All classes derive features, such as the ability to compare itself with
 other objects, from methods in the 'Basic' super-class.
 Objects which can be acted upon by algebraic operations gain this ability
 through a set of methods in a class called 'Expr'.
 These Expr objects can be held in container objects (which also subclass
 Expr) such as Mul, Add and Pow; the container objects are instantiated
 using Python's operator overloading feature which allows the constructor
 of the container class to be called whenever the appropriate binary operator
 is used (* for Mul, + for Add, and ** for Pow).
 
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Pictures/sympy_inheritance.pdf
	width 4in

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Sympy's inheritance diagram including some of the important classes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this way, additional objects can be added by simply creating a subclass
 which inherits features from the Expr class.
 These subclasses get for free certain features such as the ability to be
 compared, multiplied, added, etc.
 Herein is how Sympy creates a maintainable, modular and therefore easy
 to extend environment.
 Inheritance is magic.
 With the ability to inherit properties from higher classes, the amount
 of code required to develop, for example, a system which models quantum
 mechanics and Dirac notation decreases significantly.
\end_layout

\begin_layout Part
General Quantum Mechanics in Sympy
\end_layout

\begin_layout Standard
Sympy has a base module which provides functionality for symbolic quantum
 mechanics in Dirac notation.
 The code has a notion of ket and bra states, the operators which act on
 these states, the Hilbert spaces to which states belong, as well as inner
 and outer products of states.
 Representation of the these objects is done through the use of a represent
 function which goes through a Mul, Add, or Pow of expressions and represents
 them in the basis given as an input argument; if no basis is given, then
 the code defaults to a user-defined default basis.
 Code also exists within a function called qapply which can apply operators
 to states as well as evaluate inner products based on orthogonality rules.
 Using these bits of code as a base, code has been created which models
 Hilbert space rotations, second quantization, continuous Cartesian systems
 and quantum computation with more systems being added.
 In this way, the code has the ability to represent quantum systems in Dirac
 notation as well as preform many elementary operations on these quantum
 objects.
\end_layout

\begin_layout Standard
The base class for this module is QExpr which inherits from Expr and provides
 some features unique to quantum mechanics (such as Hilbert spaces and the
 ability to be represented).
 These abilities are inherited by all subclasses.
\end_layout

\begin_layout Standard
The following is a code example, which shows some of the capabilities of
 the module:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/genQuantum.png
	width 5.5in

\end_inset


\end_layout

\begin_layout Part
Quantum Computation in Sympy
\end_layout

\begin_layout Standard
Quantum computation is an emerging field which promises to exploit quantum
 effects (such as superpositions, entanglement, and interference) to create
 algorithms with faster asymptotic run times than what is possible with
 known classical algorithms.
 The field is of interest to individuals across many fields including mathematic
s, computer science and physics.
\end_layout

\begin_layout Standard
There is a need to provide software packages which simulate quantum computation
 for the purpose of teaching.
 For this reason, the general quantum package has been extended to include
 a quantum computing simulator.
 This includes a notion of qubit objects (which are the states of interest
 to quantum computing), and the gate objects which operate on the states.
 Many of the most well known quantum algorithms have been implemented using
 this extension including the quantum Fourier transform, Shor's order-finding
 algorithm, and Grover's brute-force search algorithm.
 With these example algorithms, someone new to the field can quickly get
 a sense for how a quantum computer would exploit quantum effects to produce
 speed-ups over known classical algorithms.
 
\end_layout

\begin_layout Standard
As stated earlier, qubit objects are the state of interest for a quantum
 computer.
 In Sympy, these states are implemented by inheriting characteristics from
 the State superclass and then teaching the qubit object how to print and
 represent itself as a matrix.
 Gate objects are implemented by inheriting properties from Operator and
 then teaching the gate class how to print, represent itself as a matrix,
 and apply itself to a qubit.
 Specific examples of quantum gates (e.g.
 Hadamard, Not, Controlled-Not, et cetera) are implemented by subclassing
 the generic Gate class and defining an associated matrix.
 The apply function works by looking at this matrix and applying it to a
 state without first representing the gate as a matrix in its full basis.
 
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/compute1.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/compute2.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/compute3.png
	width 4.5in

\end_inset


\end_layout

\begin_layout Standard
The quantum Fourier transform (QFT) is a transformation that is the key
 part of Shor's number factoring algorithm, which provides an exponential
 speedup for the problem of finding the order of a number.
 The QFT acts exactly like a discrete fourier transform except that it does
 not apply to an incoming array of data, but the state vector of a given
 system.
 There is a known short sequence of quantum gates (whose length grows polynomial
ly in the number of qubits it applies to) which implements this transformation.
 To get a sense of how this works, it would be helpful to see the Sympy
 module in action:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/QFT1.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/QFT2.png
	width 6in

\end_inset


\end_layout

\begin_layout Part
Density Operator Formalism in Sympy
\end_layout

\begin_layout Standard
In real situations found in the lab, an experimentalist cannot know with
 certainty what state a system is in.
 If the quantum state is not completely known, that is if there is a certain
 classical uncertainty as to what state a system is in, the density operator
 formalism more naturally describes the system.
 In this way, the density operator is useful for modeling systems where
 both classical uncertainty and quantum superpositions are present.
 This is useful for real systems in which the whole history of a system
 may be impossible to account for.
 Despite the clear use of density matrices, undergraduate students of quantum
 mechanics tend to focus on how a well known state vector of a system evolves.
 For this reason, it would be useful to add code which would model the density
 matrix.
\end_layout

\begin_layout Subsection
Density Operator Defined
\end_layout

\begin_layout Standard
If a system is in a state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}>$
\end_layout

\end_inset

 with a certain probability 
\begin_inset ERT
status open

\begin_layout Plain Layout

$W_{n}$
\end_layout

\end_inset

, such that
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
sum
\backslash
limits_n W_{n} = 1$
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
(That is the system is normalized such that it must be in one of the ensemble
 of given states).
 Then the density operator which defines the system is defined by:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = 
\backslash
sum
\backslash
limits_n W_{n}|
\backslash
psi_{n}><
\backslash
psi_{n}|$
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
(Note that the states 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}>$
\end_layout

\end_inset

 need not be orthogonal).
 
\end_layout

\begin_layout Standard
\noindent
\align left
In a discrete basis, the density operator takes the form of a matrix where
 the i-th and j-th matrix element is determined by the equation:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$<
\backslash
phi_{i}|
\backslash
rho|
\backslash
phi_{j}> = 
\backslash
sum
\backslash
limits_n W_{n} a_{i}^{n} a_{j}^{n*}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Blum, page 43)
\end_layout

\begin_layout Subsection
Density Operators in Sympy
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/density1.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/density2.png
	width 6in

\end_inset


\end_layout

\begin_layout Subsection
Matrix to Dirac Notation for a Density Operator
\end_layout

\begin_layout Standard
As seen in the previous segment of code, it is possible to take in a density
 matrix which represents the state of a system and determine a representation
 as a series of outer products of states using the eigenvalues and eigenvectors
 of the matrix.
 For a density matrix, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

, with eigenvalues 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda_{n}$
\end_layout

\end_inset

 and associated eigenvectors 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}>$
\end_layout

\end_inset

, the matrix can be represented as
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = 
\backslash
sum
\backslash
limits_n 
\backslash
lambda_{n} |
\backslash
psi_{n}><
\backslash
psi_{n}|$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For a non-pure state the Dirac notation representation is not unique, so
 the returned result might not be the same set of states as one may expect.
 In Sympy, this is implemented in a separate function 
\begin_inset Quotes eld
\end_inset

matrix_to_density
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Von Neumann Entropy
\end_layout

\begin_layout Standard
An important concept which can be easily determined from the density operator
 formalism is the entropy of a system.
 In rough terms, the entropy of a system measures the amount of uncertainty
 we have about what state the system is in.
 
\end_layout

\begin_layout Standard
The entropy of a system can be determined by taking the eigenvalues 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda_{n}$
\end_layout

\end_inset

 of the density operator 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

 and preforming the operation: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S = -
\backslash
sum
\backslash
limits_n 
\backslash
lambda_{n} log(
\backslash
lambda_{n})$
\end_layout

\end_inset

.
 It is easy to show (see appendix) that when the system is in a pure state,
 the only non-zero eigenvalue of the density matrix is 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda = 1$
\end_layout

\end_inset

.
 Plugging this eigenvalue into our equation for the Von Neumann entropy,
 we see that a pure state has zero entropy.
 This matches with our intuition as a perfectly well known system (a pure
 state) should not have any entropy.
\end_layout

\begin_layout Standard
In Sympy, the Von Neumann entropy is implemented for discrete systems using
 a method within the Density class.
 This method determines the eigenvalues of the density matrix by representing
 the operator as a matrix and making calls to the Sympy function which determine
s eigenvalues.
 The eigenvalues are then plugged into the equation for the Von Neumann
 entropy.
 This can be seen in the following code example:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/entropy1.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
A student of classical statistical mechanics would no doubt be aware of
 the Louisville theorem which establishes that any system evolving under
 a linear Hamiltonian will maintain the same area of uncertainty in the
 energy-momentum phase space.
 There is an equivalent form of this theorem for density operators which
 states that the uncertainty about the state of the system remains the same
 when evolving under unitary transformations.
 In other words, a pure state remains pure and a mixed state doesn't become
 any more or less mixed as it is operated on.
 One way this mathematically manifests itself is that the entropy of a state
 remains the same.
 Unitary operations are isentropic.
 This is seen below:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/entropy2.png
	width 6in

\end_inset


\end_layout

\begin_layout Subsection
The Reduced Density Matrix
\end_layout

\begin_layout Standard
Any student of quantum mechanics is aware of the definition of an entangled
 state as a state for which the constituent subsystems cannot be factored
 out.
 That is a state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
Psi >$
\end_layout

\end_inset

 with constituent systems 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
theta >$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
phi >$
\end_layout

\end_inset

 is entangled (inseparable) if and only if it is impossible to write 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
psi > = | 
\backslash
phi > 
\backslash
otimes | 
\backslash
theta >$
\end_layout

\end_inset

.
 If this condition is not met, then the system is said to be in a separable
 or entangled state.
 For this entangled state, it is impossible to describe the entangled subsystem
 on its own without the loss of information.
 If however we wish to provide a statistical account of the state of a subsystem
, the density operator provides a useful framework in the form of an object
 called the reduced density matrix.
\end_layout

\begin_layout Standard
Consider the arbitrary state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
Phi >$
\end_layout

\end_inset

 with subsystems 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
phi> $
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
theta >$
\end_layout

\end_inset

.
 Now, say that we only really care about the state of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
phi >$
\end_layout

\end_inset

.
 We can describe the state of the subsystem by the reduced density 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho_{reduced}$
\end_layout

\end_inset

, where the elements of the matrix are determined by
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$ < 
\backslash
theta 
\backslash
phi_{j} | 
\backslash
rho_{reduced} | 
\backslash
theta 
\backslash
phi_{j'} > = 
\backslash
sum
\backslash
limits_i < 
\backslash
theta_{i} 
\backslash
phi_{j} | 
\backslash
rho_{reduced} | 
\backslash
theta_{i} 
\backslash
phi_{j'} > $
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
\align left
Alternatively, we can describe the reduced density matrix in term of something
 called a partial trace 
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho_{reduced} = tr_{
\backslash
phi} | 
\backslash
Phi >< 
\backslash
Phi | $
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The big ugly sum describing the reduced density matrix is doubtlessly a
 pain to calculate (determining the reduced density matrix for even a Bell
 state requires the addition of eight numbers).
 Fortunately, I have added code to the density operator module which can
 calculate the reduced density matrix of a tensor product of two-state systems
 by specifying which bits are to be considered the unobserved bits.
 This can be seen below:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/Reduced_density_matrix.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
The operation seen above is interesting in that we went irreversibly from
 a pure entangled Bell state with zero entropy to a mixed state with non-zero
 entropy.
 In this way, the partial trace of an entangled state can be thought of
 as us 'forgetting' information about one of the qubits and thus increasing
 the entropy.
 This will generally occur whenever a partial trace is preformed on two
 entangled states.
 It is thusly apparent that the Louisville theorem discussed in the previous
 section does not generally apply to the partial trace operation as entropy
 is not conserved.
 
\end_layout

\begin_layout Standard
This shows us that a pure entangled state can appear to be a mixed unentangled
 state when we do not have information about one of the entangled systems.
 This concept sets up the framework for our understanding of decoherence.
 Decoherence is what occurs when a quantum superposition interacts with
 (and becomes entangled with) an unknown environment; this entanglement
 results in what appears to be the non-unitary transformation of quantum
 superpositions into classical mixtures.
 Mathematically, this manifests itself as a spontaneous diagonalization
 of the density matrix.
 Decoherence forms the classical/quantum barrier as this is where the weird
 effects of superposition and interference come to die.
 (the reader should note that coherence theory does not by itself solve
 the so called 'measurement problem' of quantum mechanics because measurement
 results in a definite state rather than a mixed state; we are still left
 with the question of why and when the quantum state collapsed into a pure
 definite state.
 For one interpretation of decoherence see Rolland Omes, The interpretation
 of Quantum Mechanics).
 
\end_layout

\begin_layout Subsection
Entropy of Entanglement
\end_layout

\begin_layout Standard
A wise and observant reader may have noticed that there is a very strong
 correlation between the entropy of the reduced density matrix and the entanglem
ent of the system.
 After all, the maximally entangled Bell state also produced a mixed state
 of maximal entropy under the partial trace operation.
 This observation leads to the definition of an entanglement measure called
 the 'entropy of entanglement'.
 This measure defines the entanglement of two subsystems of the state
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
Psi >$
\end_layout

\end_inset

, A and B, to be the entropy of the partial trace of the system.
 Thus:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$Entanglement( | 
\backslash
Psi >) = S(tr_{A} | 
\backslash
Psi > < 
\backslash
Psi |) = S(tr_{B} | 
\backslash
Psi > < 
\backslash
Psi |) $
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have thus added a small bit of functionality to the code which determines
 the entropy of entanglement between any specified qubit and the system
 as a whole.
 This is seen below:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename Pictures/Entropy_of_entanglement.png
	width 6in

\end_inset


\end_layout

\begin_layout Part
Conclusions and Future Directions
\end_layout

\begin_layout Standard
Sympy's quantum code base so far has built into it a notion of Dirac notation,
 the gate model of quantum computation, and the density matrix.
 The quantum computational module has all of the structures important to
 the gate model of quantum computation, and as such can simulate quantum
 algorithms.
 The density matrix object has the capability to be represented, acted upon
 by operators, determine the entropy of a state, and determine the entropy
 of entanglement.
 In this way, the code is quite capable of modeling systems.
\end_layout

\begin_layout Standard
We can see from the examples that the code greatly eases the algebraic and
 arithmetic difficulty in simulating quantum mechanical systems.
 The code therefore could be used as a very powerful teaching tool.
 The added code doubtlessly has potential for modeling certain quantum phenomena.
 However, because the code is in its infancy, very few simulations of physical
 systems have been written using this framework.
 When more examples using this code are written, the module will be of great
 use for teaching quantum mechanics and quantum information concepts.
 
\end_layout

\begin_layout Bibliography
\start_of_appendix
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

Blum, Karl.
 Density Matrix Theory and Applications.
 Plenum Press, New York, 1996.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset


\begin_inset Quotes erd
\end_inset

Entropy of Entanglement
\begin_inset Quotes erd
\end_inset

, Quantiki.
 Web.
 Accessed 1 Jun 2011.
 http://www.quantiki.org/wiki/Entropy_of_entanglement.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

Nielsen, Micheal.
 Chuang, Isaac.
 Quantum Computation and Quantum Information.
 Cambridge Press, New York, 1996.
\end_layout

\begin_layout Standard
Further information and downloads for Sympy can be found at Sympy.org
\end_layout

\begin_layout Subsection*
Appendix A
\end_layout

\begin_layout Standard
Simple proof that 1 is the only non-zero eigenvalue for a pure state:
\end_layout

\begin_layout Standard
Suppose we have a generic pure state density matrix defined by 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = |
\backslash
psi><
\backslash
psi|$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The eigenvalue problem for 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho|
\backslash
phi> = 
\backslash
lambda |
\backslash
phi>$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is clear that 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
phi> = |
\backslash
psi>$
\end_layout

\end_inset

 is a solution for this eigenvector problem as 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho |
\backslash
psi> = |
\backslash
psi><
\backslash
psi|
\backslash
psi> = |
\backslash
psi>$
\end_layout

\end_inset

 (since the inner product 
\begin_inset ERT
status open

\begin_layout Plain Layout

$<
\backslash
psi|
\backslash
psi> = 1$
\end_layout

\end_inset

).
 Note that 1 is the eigenvalue associated with the eigenvector 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi>$
\end_layout

\end_inset

.
 Since we know that 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
sum_{n} 
\backslash
lambda_{n} = 1$
\end_layout

\end_inset

, the other eigenvalues must be zero.
 QED.
\end_layout

\begin_layout Subsection*
The Zen of Python
\end_layout

\begin_layout Verse
Beautiful is better than ugly.
\end_layout

\begin_layout Verse
Explicit is better than implicit.
\end_layout

\begin_layout Verse
Simple is better than complex.
\end_layout

\begin_layout Verse
Complex is better than complicated.
\end_layout

\begin_layout Verse
Flat is better than nested.
\end_layout

\begin_layout Verse
Sparse is better than dense.
 
\end_layout

\begin_layout Verse
Readability counts.
\end_layout

\begin_layout Verse
Special cases aren't special enough to break the rules.
\end_layout

\begin_layout Verse
Although practicality beats purity.
 
\end_layout

\begin_layout Verse
Errors should never pass silently.
 Unless explicitly silenced.
\end_layout

\begin_layout Verse
In the face of ambiguity, refuse the temptation to guess.
\end_layout

\begin_layout Verse
There should be one-- and preferably only one --obvious way to do it.
\end_layout

\begin_layout Verse
Although that way may not be obvious at first unless you're Dutch.
 
\end_layout

\begin_layout Verse
Now is better than never.
 
\end_layout

\begin_layout Verse
Although never is often better than *right* now.
\end_layout

\begin_layout Verse
If the implementation is hard to explain, it's a bad idea.
 
\end_layout

\begin_layout Verse
If the implementation is easy to explain, it may be a good idea.
 
\end_layout

\begin_layout Verse
Namespaces are one honking great idea -- let's do more of those!
\end_layout

\begin_layout Verse
--The Zen of Python
\end_layout

\end_body
\end_document
