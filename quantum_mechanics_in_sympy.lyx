#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Quantum Mechanics, Quantum Computation, and the Density Operator in Sympy
\end_layout

\begin_layout Author
Addison Cugini
\end_layout

\begin_layout Date
05/27/2011
\end_layout

\begin_layout Abstract
Because aspects of quantum mechanics are both difficult to understand and
 difficult algebraically, there is a need for software which symbolically
 .
 This paper shall discuss the code that has been added to a python-based
 CAS Sympy which 
\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Standard
Students unfamiliar with quantum mechanics oftentimes find themselves getting
 lost in arithemetic and algebraic details and consequently have a hard
 time grasping the fundamental concepts behind the theory.
 For this reason, there is a need for software which simplifies the process
 by doing much of the meticulous algebra for the user.
 There is no doubt that a symbolic engine would be highly useful for attaining
 this goal.
\end_layout

\begin_layout Standard
This paper shall discuss the quantum mechanics simulation code that has
 been added to the CAS Sympy during the 2010 Google Summer of Code and during
 my senior project.
 Code has been added which uses Dirac notation to simulate quantum computing
 and the density operator.
 These modules, as well as the underlying physical threories, shall be discussed.
\end_layout

\begin_layout Part
Python and Sympy
\end_layout

\begin_layout Standard
Python is a high level programming language that aims to be easy to use
 and easy to learn.
 To further this aim, the language supports multiple programming paradigms
 including functional, imperative and object oriented; both functions and
 classes are considered first class citizens.
 In contrast to Perl's credo 
\begin_inset Quotes eld
\end_inset

There is more than one way to do it
\begin_inset Quotes erd
\end_inset

, The Zen of Python asserts 
\begin_inset Quotes eld
\end_inset

There should be one--and preferably only one--obvious way to do it
\begin_inset Quotes erd
\end_inset

.
 In this way, Python aims to be easy to read and learn by providing only
 one obvious way to solve a particular task (Perl is infamous for requiring
 people to learn too many programming techniques).
\end_layout

\begin_layout Standard
Keeping with its simplicity, Python is an interactive interpreted language,
 which means that code does not need to be compiled and can be typed directly
 into an interpreter.
 In addition to the basic command line Python interpreter, a third-party
 open-source package called iPython adds shell functionality.
 This includes the such basic functionality as changing directories, running
 files, listing files in a directory, as well as more advanced features
 such as tab completion and a history of commands run.
 The most bleeding edge versions of iPython allow for rendering of the common
 typesetting languages LaTex and HTML.
 These features create an environment that makes it easy to test code.
 All code examples contain in this document were created using this version
 of iPython.
\end_layout

\begin_layout Standard
Python has several modules which provide functionality that is useful for
 mathematics and scientific computing.
 Fast numerical algorithms on matrices and arrays are supplied by the Scipy
 and Numpy modules, which have run times nearly as fast as hand-written
 C/C++ code.
 These modules are competitors to Matlab with the advantage of using a much
 more manageable programming language.
 Sympy is a computer algebra system which hopes to compete with well established
 symbolic engines such as Mathematica, Maple or Maxima.
 Features include support for algebraic simplifications, ODE solving, integratio
n (the Risch Algorithm is partially implemented), linear algebra and more.
 
\end_layout

\begin_layout Standard
Sympy's symbolic engine takes advantage of object orientation (and inheritance
 in particular) to create an easily extensible code base.
 All classes derive features, such as the ability to compare itself with
 other objects, from methods in the 'Basic' super-class.
 Objects which can be acted upon by algebraic operations gain this ability
 through a set of methods in a class called 'Expr'.
 These Expr objects can be held in container objects (which also subclass
 Expr) such as Mul, Add and Pow; the objects are instantiated using Python's
 operator overloading feature which allows the constructor of the container
 class to be called whenever the appropriate binary operator is used (*
 for Mul, + for Add, and ** for Pow).
 The following is an inheritance diagram which shows some important classes:
 
\end_layout

\begin_layout Standard
In this way, additional objects can be added by simply creating a subclass
 which inherits features from the Expr class.
 These subclasses get for free certain features such as the ability to be
 compared, multiplied, added, etc.
 Herein is how Sympy creates a maintainable, modular and therefore easy
 to extend enviornment.
 Inheritance is magic.
 With the ability to inherit properties from higher classes, the amount
 of code required to develop, for example, a system which models quantum
 mechanics and Dirac notation decreases significantly.
\end_layout

\begin_layout Part
General Quantum Mechanics in Sympy
\end_layout

\begin_layout Standard
Sympy has a base module which provides functionality for symbolic quantum
 mechanics in Dirac notation.
 The code has a notion of ket and bra states, the operators which act on
 these states, the Hilbert spaces to which states belong, as well as inner
 and outer products of states.
 Representation of the these objects is done through the use of a represent
 function which goes through a Mul, Add, or Pow of expressions and represents
 them in the basis given as an input argument; if no basis is given, then
 the code defaults to a user-defined default basis.
 Code also exists within a function called qapply which can apply operators
 to states as well as evaluate inner products based on orthogonality rules.
 Using these bits of code as a base, code has been created which models
 Hilbert space rotations, second quantization, continous cartesian systems
 and quantum computation with more systems being added.
 In this way, the code has the ability to represent quantum systems in Dirac
 notation as well as preform many elementary operations on these quantum
 objects.
\end_layout

\begin_layout Standard
The base class for this module is QExpr which inherits from Expr and provides
 some features unique to quantum mechanics (such as Hilbert spaces and the
 ability to be represented).
 These abilities are inherited by all subclasses.
\end_layout

\begin_layout Standard
A look at the inheritance diagram:
\end_layout

\begin_layout Standard
Code example:
\end_layout

\begin_layout Part
Quantum Computation in Sympy
\end_layout

\begin_layout Standard
Quantum computation is an emerging field which promises to exploit the quantum
 effects (such as superpositions, entanglement, and interference) to create
 algorithms with faster asymptotic run times than what is possible with
 known classical algorithms.
 The field is of intrest to individuals across many fields including mathematics
, computer science and physics.
\end_layout

\begin_layout Standard
There is a need to provide software packages which simulate quantum computation
 for the purpose of teaching.
 For this reason, the general quantum package has been extended to include
 a quantum computing simulator.
 This includes a notion of qubit objects (which are the states of intrest
 to quantum computing), and the gate objects which operate on the states.
 Many of the most well known quantum algorithms have been implemented using
 this extension including the quantum Fourier transform, Shor's order-finding
 algorithm, and Grover's brute-force search algorithm.
 With these example algorithms, someone new to the field can quickly get
 a sense for how a quantum computer would exploit quantum effects to produce
 asymptotic speed-ups over known classical algorithms.
 
\end_layout

\begin_layout Standard
As stated earlier, qubit objects are the state of interest for a quantum
 computer.
 In Sympy, these states are implemented by inheriting characteristics from
 ...
 Gate objects are implemented by inheriting...A method that knows how to apply
 a gate to a qubit object can be found in the generic gate superclass, with
 this bit of code a user need only specify what the matrix for a gate looks
 like in order to operate on a state without first representing the gate
 as a matrix in its full basis.
 
\end_layout

\begin_layout Standard
The quantum fourier transform (QFT) is a transformation that is the key
 part of Shor's number factoring algorithm, which provides an exponential
 speedup for the problem of finding the order of a number.
 The QFT acts exactly like a discrete fourier transform except that it does
 not apply to an incoming array of data, but the state vector of a given
 system.
 A short sequence of gates, which grows polynomially in the number of qubits
 it applies to, is known which implements this transformation.
 To get a sense of how this works, it would be helpful to see the Sympy
 module in action:
\end_layout

\begin_layout Part
Density Operator Formalism in Sympy
\end_layout

\begin_layout Standard
In real situations found in the lab, an experimentalist cannot know with
 certainty what state a system is in.
 Students of quantum mechanics tend to focus on how a well known state vector
 of a system evolves.
 If the quantum state is not completely known, that is if there is a certain
 classical uncertainty as to what state a system is in, the density operator
 formalism more naturally describes the system.
 In this way, the density operator is useful for modeling systems where
 both classical uncertainty and quantum superpositions are present.
 This is useful for real systems in which the whole history of a system
 may be impossible to account for.
\end_layout

\begin_layout Subsection
Density Operator Defined
\end_layout

\begin_layout Standard
If a system is in a state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}>$
\end_layout

\end_inset

 with a certain probability 
\begin_inset ERT
status open

\begin_layout Plain Layout

$W_{n}$
\end_layout

\end_inset

, such that 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
sum_{n} W_{n} = 1$
\end_layout

\end_inset

 (That is the system is normalized such that it must be in one of the ensemble
 of given states).
 Then the density operator which defines the system is defined by:
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = 
\backslash
sum_{n} W_{n}|
\backslash
psi_{n}><
\backslash
psi_{n}|$
\end_layout

\end_inset

.
 (Note that the states 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}>$
\end_layout

\end_inset

 need not be orthoganol).
 
\end_layout

\begin_layout Standard
In a discrete basis, the density operator takes the form of a matrix where
 the i-th and j-th matrix element is determined by the equation: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$<
\backslash
phi_{i}|
\backslash
rho|
\backslash
phi_{j}> = 
\backslash
sum_{n} W_{n} a_{i}^{n} a_{j}^{n*}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Blum, page 43)
\end_layout

\begin_layout Subsection
Density Operators in Sympy
\end_layout

\begin_layout Subsection
Matrix to Dirac Notation for a Density Operator
\end_layout

\begin_layout Standard
It is possible to take in a density matrix which represents the state of
 a system and determine a representation as a series of outer products of
 states using the eigenvalues and eigenvectors of the matrix.
 For a density matrix, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

, with eigenvalues 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda_{n}$
\end_layout

\end_inset

 and associated eigenvectors 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}>$
\end_layout

\end_inset

, the matrix can be represented as 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = 
\backslash
sum_{n} 
\backslash
lambda_{n} |
\backslash
psi_{n}><
\backslash
psi_{n}|$
\end_layout

\end_inset

.
 For a non-pure state the Dirac notation representation is not unique, so
 the returned result might not be the same set of states as one may expect.
 In Sympy, this is implemented in a separate function 
\begin_inset Quotes eld
\end_inset

matrix_to_density
\begin_inset Quotes erd
\end_inset

.
 This is seen in the following code example: 
\end_layout

\begin_layout Subsection
Von Neumann Entropy
\end_layout

\begin_layout Standard
An important concept which can be easily determined from the density operator
 formalism is the entropy of a system.
 In rough terms, the entropy of a system measures the amount of uncertainty
 we have about what state the system is in.
 
\end_layout

\begin_layout Standard
The entropy of a system can be determined by taking the eigenvalues 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda_{n}$
\end_layout

\end_inset

 of the density operator 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

 and preforming the operation: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S = -
\backslash
sum_{n} 
\backslash
lambda_{n} log(
\backslash
lambda_{n})$
\end_layout

\end_inset

.
 It is easy to show (see appendix) that when the system is in a pure state,
 the only non-zero eigenvalue of the density matrix is 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda = 1$
\end_layout

\end_inset

.
 Plugging this eigenvalue into our equation for the Von Neumann entropy,
 we see that a pure state has zero entropy.
 This matches with our intuition as a perfectly well known system (a pure
 state) should not have any entropy.
\end_layout

\begin_layout Standard
In Sympy, the Von Neumann entropy is implemented for discrete systems using
 a method within the Density class.
 This method determines the eigenvalues of the density matrix by representing
 the operator as a matrix and making calls to the sympy function which determine
s eigenvalues.
 The eigenvalues are then plugged into the equation for the Von Neumann
 entropy.
 This can be seen in the following code example:
\end_layout

\begin_layout Subsection
The Reduced Density Matrix
\end_layout

\begin_layout Standard
Any student of quantum mechanics is aware of the definiton of an entangled
 state as a state for which the consituent subsystems cannot be factored
 out.
 That is a state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
Psi >$
\end_layout

\end_inset

 with constituent systems 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
theta >$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
phi >$
\end_layout

\end_inset

 is entangled (unseperable) if and only if it is impossible to write 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
psi > = | 
\backslash
phi > 
\backslash
otimes | 
\backslash
theta >$
\end_layout

\end_inset

.
 If this condition is not met, then the system is said to be in a seperable
 or unentangled state.
 For this entangled state, it is impossible to describe the entangled subsystem
 on its own without the loss of information.
 If however we wish to provide a statistical account of the state of a subsystem
, the density operator provides a useful framework in the form of an object
 called the reduced density matrix.
\end_layout

\begin_layout Standard
Consider the arbitrary state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
Phi >$
\end_layout

\end_inset

 with subsystems 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
phi> $
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
theta >$
\end_layout

\end_inset

.
 Now, say that we only really care about the state of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
phi >$
\end_layout

\end_inset

.
 We can describe the state of the subsystem by the reduced density 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho_{reduced}$
\end_layout

\end_inset

, where the elements of the matrix are determined by 
\begin_inset ERT
status open

\begin_layout Plain Layout

$ < 
\backslash
theta 
\backslash
phi_{j} | 
\backslash
rho_{reduced} | 
\backslash
theta 
\backslash
phi_{j'} > = 
\backslash
sum
\backslash
limits_i < 
\backslash
theta_{i} 
\backslash
phi_{j} | 
\backslash
rho_{reduced} | 
\backslash
theta_{i} 
\backslash
phi_{j'} > $
\end_layout

\end_inset

.
 Alternatively, we can describe the reduced density matrix in term of something
 called a partial trace 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho_{reduced} = tr_{
\backslash
phi} 
\backslash
Phi$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The big ugly sum describing the reduced density matrix is doubtlessly a
 pain to calculate (determining the reduced density matrix for even a Bell
 state requires the addition of eight numbers).
 Fortunately, I have added code to the density operator module which can
 calculate the reduced density matrix of a tensor product of two-state systems
 by specifying which bits are to be considered the unobserved bits.
 This can be seen below:
\end_layout

\begin_layout Standard
The operation seen above is intresting in that we went irreversiblly from
 a pure entangled Bell state with zero entropy to a mixed state with non-zero
 entropy.
 In this way, the partial trace of an entangled state can be thought of
 as us 'forgetting' information about one of the qubits and thus increasing
 the entropy.
 This will generally occur whenever a partial trace is preformed on two
 entangled states.
 It is thusly apparent that the Louiville theorem discussed in the previous
 section does not generally apply to the partial trace operation as entropy
 is not conserved.
 
\end_layout

\begin_layout Standard
This shows us that a pure entangled state can appear to be a mixed unentangled
 state when we do not have information about one of the entangled systems.
 This concept sets up the framework for our understanding of decoherence.
 Decoherence is what occurs when a quantum superposition interacts with
 (and becomes entangled with) an unknown enviorment; this entanglement results
 in what appears to be the non-unitary transformation of quantum superpositions
 into classical mixtures.
 Mathematically, this manifests itself as a spontaneous diagonalization
 of the density matrix.
 Decoherence forms the classical/quantum barrier as this is where the wierd
 effects of superposition and intereference come to die.
 (the reader should note that decoherence theory does not by itself solve
 the so called 'measurement problem' of quantum mechanics because measurement
 results in a definite state rather than a mixed state; we are still left
 with the question of why and when the quantum state collapsed into a pure
 definite state.
 For one interpretation of decoherence see Rolland Omes, The interpretation
 of Quantum Mechanics).
 
\end_layout

\begin_layout Subsection
Entropy of Entanglement
\end_layout

\begin_layout Standard
A wise and observant reader may have noticed that there is a very strong
 correlation between the entropy of the reduced density matrix and the entanglem
ent of the system.
 After all, the maximally entangled Bell state also produced a mixed state
 of maximal entropy under the partial trace operation.
 This observation leads to the definition of an entanglement measure called
 the 'entropy of entanglement'.
 This measure defines the entanglement of two subsystems of 
the state
\lang english

\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
Psi >$
\end_layout

\end_inset

, A and B, to be the entropy of the partial trace of the system.
 Thus:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$Entanglement( | 
\backslash
Psi >) = S(tr_{A} | 
\backslash
Psi > < 
\backslash
Psi |) = S(tr_{B} | 
\backslash
Psi > < 
\backslash
Psi |) $
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have thus added a small bit of functionality to the code which determines
 the entropy of entanglement between any specified qubit and the system
 as a whole.
 This is seen below
\end_layout

\begin_layout Standard
http://qwiki.stanford.edu/index.php/Entropy_of_Entanglement
\end_layout

\begin_layout Part
Conclusions and Future Directions
\end_layout

\begin_layout Standard
The addition of quantum computation simulation code to the code 
\end_layout

\begin_layout Standard
The code that has been added to Sympy provides many useful bits of functionality
, but the possible additions that could be made are nearly limitless.
 
\end_layout

\begin_layout Subsection*
\start_of_appendix
Appendix A
\end_layout

\begin_layout Standard
Simple 'proof' that 1 is the only non-zero eigenvalue for a pure state:
\end_layout

\begin_layout Standard
Suppose we have a generic pure state density matrix defined by 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = |
\backslash
psi><
\backslash
psi|$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The eigenvalue problem for 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho|
\backslash
phi> = 
\backslash
lambda |
\backslash
phi>$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is clear that 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
phi> = |
\backslash
psi>$
\end_layout

\end_inset

 is a solution for this eigenvector problem as 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho |
\backslash
psi> = |
\backslash
psi><
\backslash
psi|
\backslash
psi> = |
\backslash
psi>$
\end_layout

\end_inset

 (since the inner product 
\begin_inset ERT
status open

\begin_layout Plain Layout

$<
\backslash
psi|
\backslash
psi> = 1$
\end_layout

\end_inset

).
 Note that 1 is the eigenvalue associated with the eigenvector 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi>$
\end_layout

\end_inset

.
 Since we know that 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
sum_{n} 
\backslash
lambda_{n} = 1$
\end_layout

\end_inset

, the other eigenvalues must be zero.
 QED.
\end_layout

\end_body
\end_document
