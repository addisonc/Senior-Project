#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1.5in
\topmargin 1.5in
\rightmargin 1.5in
\bottommargin 1.5in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Quantum Mechanics, Quantum Computation, and the Density Operator in SymPy
\end_layout

\begin_layout Author
Addison Cugini
\end_layout

\begin_layout Date
06/05/2011
\end_layout

\begin_layout Abstract
Because aspects of quantum mechanics are both difficult to understand and
 difficult algebraically, there is a need for software which symbolically
 simulates quantum mechanical phenomena.
 To accomplish this goal, code has been added to an open-source computer
 algebra system, called SymPy, which models the abstraction of Dirac notation
 and the density operator.
 Additionally, a quantum computer simulation has been built using this abstracti
on.
 This paper shall discuss the code that has been added as well as any relevant
 physics important to understanding the code.
 In particular, we shall focus on the density operator of statistical quantum
 mechanics using SymPy's density matrices as a guide.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Students unfamiliar with quantum mechanics oftentimes find themselves getting
 lost in arithmetic and algebraic details and consequently have a hard time
 grasping the fundamental concepts behind the theory.
 For this reason, there is a need for software which simplifies the learning
 process by doing much of the meticulous algebra for the user.
 There is no doubt that a symbolic engine would be highly useful for attaining
 this goal.
 With this in mind, we have added code to an open source project called
 SymPy, which extends the Python programming language to handle symbolic
 computation.
 The code we have added includes both a base layer which implements abstract
 Dirac notation in SymPy, as well as specific sub-modules which model specific
 quantum systems.
\end_layout

\begin_layout Standard
This paper will discuss the basic quantum mechanics simulation code that
 was added to the Computer Algebra System (CAS) SymPy during the 2010 Google
 Summer of Code by Matt Curry and Dr Brian Granger.
 This includes a general introduction to the syntax and data structures
 of SymPy as well as a look at how this was used to implement Dirac notation.
 The code provides a notion of states, operators, commutators, anticommutators
 and many other quantum mechanical structures.
 These structures can be represented in a basis, as well as simplified using
 a function called 
\family typewriter
qapply
\family default
.
 In this way, the base layer can be used to create simulations of many quantum
 mechanical systems.
\end_layout

\begin_layout Standard
One such system which was implemented is a quantum computer.
 We shall then look at how this Dirac Notation was used to simulate the
 gate model of quantum computation.
 The quantum computing module inherits much of its capabilities from the
 main quantum base layer.
 We shall look at how this occurs and what capabilities the module currently
 has.
\end_layout

\begin_layout Standard
Finally, we shall discuss the density operator of statistical quantum mechanics
 and how we recently extended the code to model its use.
 The code (and discussion of its meaning) was developed during Addison Cugini's
 senior project.
 We shall include a discussion of the important physics concepts which come
 from the study of the density operator.
 This includes a discussion of the Von Neumann entropy and how it relates
 to the Louiville Theorem.
 Additionally, we shall look at how the reduced density matrix of a subsystem
 is calculated and use this knowledge to inform our understanding of quantum
 decoherence and the 
\begin_inset Quotes eld
\end_inset

entropy of entanglement
\begin_inset Quotes erd
\end_inset

 measure of entanglement.
 
\end_layout

\begin_layout Section
Python and SymPy
\end_layout

\begin_layout Standard
Python is a high level programming language that aims to be easy to use
 and easy to learn.
 To further this aim, the language supports multiple programming paradigms
 including functional, imperative and object oriented; both functions and
 classes are considered first class citizens.
 In contrast to Perl's credo 
\begin_inset Quotes eld
\end_inset

There is more than one way to do it
\begin_inset Quotes erd
\end_inset

, The Zen of Python asserts 
\begin_inset Quotes eld
\end_inset

There should be one--and preferably only one--obvious way to do it
\begin_inset Quotes erd
\end_inset

.
 In this way, Python aims to be easy to read and learn by providing only
 one obvious way to solve a particular task (Perl is infamous for requiring
 people to learn too many programming techniques).
\end_layout

\begin_layout Standard
Keeping with its simplicity, Python is an interactive, interpreted language,
 which means that code does not need to be compiled and can be typed directly
 into an interpreter.
 In addition to the basic command line Python interpreter, a third-party
 open-source package called IPython adds shell functionality.
 This includes basic functionality, such as changing directories, running
 files, listing files in a directory, as well as more advanced features
 such as tab completion and command history.
 The bleeding edge versions of IPython allow for rendering of the common
 typesetting languages LaTeX and HTML.
 These features create an environment that makes it easy to test code.
 All code examples contained in this document were created using this version
 of IPython.
\end_layout

\begin_layout Standard
Python has several modules which provide functionality that is useful for
 mathematics and scientific computing.
 Fast numerical algorithms on matrices and arrays are supplied by the Scipy
 and Numpy modules, which have run times nearly as fast as hand-written
 C/C++ code.
 These modules are competitors to Matlab with the advantage of using a much
 more manageable and scalable programming language.
 SymPy is a computer algebra system which hopes to compete with well established
 symbolic engines such as Mathematica, Maple or Maxima.
 Features include support for algebraic simplifications, ODE solving, integratio
n (the Risch Algorithm is partially implemented), linear algebra, LaTeX
 printing of expressions and more.
 
\end_layout

\begin_layout Standard
What follows is a short demonstration of the general symbolic capabilities
 of SymPy rendered in the bleeding edge version of IPython.
 All code was attained by screen-grabbing the input-output of the IPython
 notebook; there is no magic and no trickery, the notebook actually renders
 LaTeX code.
 This example is done so that the reader can understand the clear syntax
 SymPy provides.
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/generalSympy.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
The code above shows the creation of an algebraic expression, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
frac{x^{2}+y^{2}}{x}$
\end_layout

\end_inset

, using standard Python operators for division, addition, and powers.
 The code allows for taking derivatives of expressions using the 
\family typewriter
diff
\family default
 function, which takes an algebraic expression as its first argument and
 the second argument is the variable in which the derivative was taken.
 The 
\family typewriter
integrate
\family default
 function takes the same arguments and returns the integral of the input
 expression.
 
\end_layout

\begin_layout Subsection
Data Structures in SymPy
\end_layout

\begin_layout Standard
SymPy's symbolic engine takes advantage of object orientation (inheritance
 in particular) to create an easily extensible code base.
 All classes derive features, such as the ability to compare itself with
 other objects, from methods in the 
\family typewriter
Basic
\family default
 super-class.
 Objects which can be acted upon by algebraic operations gain this ability
 through a set of methods in a class called 
\family typewriter
Expr
\family default
.
 These 
\family typewriter
Expr
\family default
 objects can be held in container objects (which also subclass 
\family typewriter
Expr
\family default
) such as 
\family typewriter
Mul
\family default
, 
\family typewriter
Add
\family default
 and 
\family typewriter
Pow
\family default
; the container objects are instantiated using Python's operator overloading
 feature which allows the constructor of the container class to be called
 whenever the appropriate binary operator is used (
\family typewriter
*
\family default
 for 
\family typewriter
Mul
\family default
, 
\family typewriter
+
\family default
 for 
\family typewriter
Add
\family default
, and 
\family typewriter
**
\family default
 for 
\family typewriter
Pow
\family default
).
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Pictures/sympy_inheritance.pdf
	width 4in

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
SymPy's inheritance diagram including some of the important classes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this way, additional objects can be added by simply creating a subclass
 which inherits features from the 
\family typewriter
Expr
\family default
 class.
 These subclasses get for free certain features such as the ability to be
 compared, multiplied, added, etc.
 Herein is how SymPy creates a maintainable, modular and therefore easy
 to extend environment.
 With the ability to inherit properties from higher classes, the amount
 of code required to develop, for example, a system which models quantum
 mechanics and Dirac notation decreases significantly.
\end_layout

\begin_layout Section
General Quantum Mechanics in SymPy
\end_layout

\begin_layout Standard
SymPy has a base module which provides functionality for symbolic quantum
 mechanics in Dirac notation.
 Much of this functionality was added during the 2010 Google Summer of Code
 by Matt Curry and his advisor Dr.
 Brian Granger, with some help/input from Addison Cugini.
 The code has a notion of ket and bra states, the operators which act on
 these states, the Hilbert spaces to which states and operators belong,
 as well as inner, outer and tensor products.
 Representation of the these objects is done through the use of a 
\family typewriter
represent
\family default
 function which goes through a 
\family typewriter
Mul
\family default
, 
\family typewriter
Add
\family default
, or 
\family typewriter
Pow
\family default
 of expressions and represents them in the basis given as an input argument;
 if no basis is given, then the code uses a default basis.
 Code also exists within a function called 
\family typewriter
qapply
\family default
 which can apply operators to states as well as evaluate inner products
 based on orthogonality rules.
 Using these bits of code as a base, a variety of quantum systems have been
 implemented including: Hilbert space rotations, second quantization, continuous
 Cartesian systems and quantum computation with more systems being added.
 In this way, the code has the ability to represent quantum systems in Dirac
 notation as well as preform many elementary operations on these quantum
 objects.
\end_layout

\begin_layout Standard
The base class for this module is 
\family typewriter
QExpr
\family default
 which inherits from 
\family typewriter
Expr
\family default
 and provides some features unique to quantum mechanics (such as Hilbert
 spaces and the ability to be represented).
 These abilities are inherited by all subclasses.
\end_layout

\begin_layout Standard
The following is a code example, which shows some of the capabilities of
 the module:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/genQuantum.png
	width 5.5in

\end_inset


\end_layout

\begin_layout Standard
The above code produces an arbitrary superposition of 
\family typewriter
Ket
\family default
 states by forming an algebraic expression of 
\family typewriter
Ket
\family default
 objects.
 The 
\family typewriter
Ket
\family default
 constructor takes as its argument the label that will identify the state.
 The dagger of this state is formed by calling the 
\family typewriter
Dagger
\family default
 class's constructor which distributes the dagger operation on each ket,
 thus producing the superposition of bra states that we see.
 We use 
\family typewriter
qapply
\family default
 to form the inner and outer products that we see in the last two outputs.
\end_layout

\begin_layout Section
Quantum Computation in SymPy
\end_layout

\begin_layout Standard
Quantum computation is an emerging field which promises to exploit quantum
 effects (such as superpositions, entanglement, and interference) to create
 algorithms with faster asymptotic run times than what is possible with
 known classical algorithms.
 The field is of interest to individuals across many fields including mathematic
s, computer science and physics.
\end_layout

\begin_layout Standard
There is a need to provide software packages which simulate quantum computers
 for the purpose of teaching and research.
 For this reason, the general quantum package has been extended to include
 a quantum computer simulator.
 This includes a notion of 
\family typewriter
Qubit
\family default
 objects (which are the states of interest to quantum computing), and the
 
\family typewriter
Gate
\family default
 objects which operate on the states.
 Many of the most well known quantum algorithms have been implemented using
 this extension including the quantum Fourier transform, Shor's order-finding
 algorithm, and Grover's search algorithm.
 With these example algorithms, someone new to the field can quickly get
 a sense for how a quantum computer would exploit quantum effects to produce
 speed-ups over known classical algorithms.
 Additionally, researchers may be able to use the software to test new algorithm
s and gain intuition for how the algorithm functions.
\end_layout

\begin_layout Standard
As stated earlier, qubit objects are the state of interest for a quantum
 computer.
 In SymPy, these states are implemented by inheriting characteristics from
 the 
\family typewriter
State
\family default
 superclass and then teaching the qubit object how to print and represent
 itself as a vector.
 
\family typewriter
Gate
\family default
 objects are implemented by inheriting properties from 
\family typewriter
Operator
\family default
 and then teaching the gate class how to print, represent itself as a matrix,
 and apply itself to a qubit.
 Specific examples of quantum gates (e.g.
 
\family typewriter
H
\family default
, 
\family typewriter
X
\family default
, 
\family typewriter
CNOT
\family default
, etc) are implemented by subclassing the generic 
\family typewriter
Gate
\family default
 class and defining an associated matrix.
 The 'qapply' function works by looking at this matrix and applying it to
 a state without first representing the gate as a matrix in its full basis.
 
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/compute1.png
	width 5.2in

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/compute2.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/compute3.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
The code above shows Sympy's general quantum computational capabilities.
 As in the general quantum example, we create Qubit states and Qubit superpositi
ons as well as Gate operators.
 We can see from the results of Python's 'isinstance' function that Qubit
 and Gate are indeed subclasses of State and Operator respectively.
 In the case of the Qubit class, the argument passed to the constructor
 determines in what state the individual qubits are; Qubit('00') produces
 a ket where both the 0-th and 1st bit are set to zero.
 By multiplying a sequence of gates together, we produce a quantum circuit.
 This circuit is printed using the 'circuit_plot' function, which takes
 a quantum circuit as the first argument and the number of qubits that it
 acts on as the second.
 Likewise, we represent the circuit as a matrix using the 'represent' function
 which takes the same arguments as the 'circuit_plot' function.
 We then use of 'qapply' to apply a Hadamard gate to the state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|00
\backslash
rangle$
\end_layout

\end_inset

 which produces a superposition of states.
 We then use the for-loop syntax to produce a superposition with alternating
 phases on odd and even kets.
 The IntQubit class, which is a subclass of Qubit, displays itself in decimal
 form rather than binary.
\end_layout

\begin_layout Subsection
The Quantum Fourier Transform
\end_layout

\begin_layout Standard
The quantum Fourier transform (QFT) is a key part of Shor's number factoring
 algorithm, which provides an exponential speedup for the problem of finding
 the order of a number.
 The QFT acts exactly like a discrete Fourier transform except that it does
 not apply to an incoming array of data, but the state vector of a given
 system.
 There is a known short sequence of quantum gates (whose length grows polynomial
ly in the number of qubits it applies to) which implements this transformation.
 To get a sense of how this works, it would be helpful to see the SymPy
 module in action:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/QFT1.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
QFT
\family default
 class is called with the first argument of the 
\family typewriter
QFT
\family default
 class being the first bit it applies to and the second argument is the
 number of bits to which it applies.
 The 
\family typewriter
QFT
\family default
 class and 
\family typewriter
IQFT
\family default
 classes are created which act on the 0th through 2nd bit, and then the
 decompose method is called which displays the transform in terms of elementary
 gates.
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/QFT2.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
The above code shows us actually applying the QFT to a state.
 In particular, we apply the QFT to three qubits which oscillates with a
 frequency of 4 cycles across the domain.
 One would expect that the frequency of this state would be 4; this indeed
 occurs when we apply the QFT to the state.
 In this way, we can see that a QFT is really not all that different from
 a standard DFT.
 
\end_layout

\begin_layout Section
Density Operator Formalism in SymPy
\end_layout

\begin_layout Standard
In real situations found in the lab, an experimentalist cannot know with
 certainty what state a system is in.
 If the quantum state is not completely known, that is if there is a classical
 uncertainty as to what state a system is in, the density operator (or density
 matrix) formalism more naturally describes the system.
 In this way, the density operator is useful for modeling systems where
 both classical uncertainty and quantum superpositions are present.
 This is useful for real systems in which the whole history of a system
 may be impossible to account for.
 Despite the clear use of density matrices, undergraduate students of quantum
 mechanics tend to focus on how a well known state vector of a system evolves.
 For this reason, it is useful to add code which would model the density
 matrix.
\end_layout

\begin_layout Subsection
Density Operator Defined
\end_layout

\begin_layout Standard
If a system is in a state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}
\backslash
rangle$
\end_layout

\end_inset

 with a certain classical probability 
\begin_inset ERT
status open

\begin_layout Plain Layout

$W_{n}$
\end_layout

\end_inset

, such that
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
sum
\backslash
limits_n W_{n} = 1$
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
(That is the system is normalized such that it must be in one of the ensemble
 of given states).
 Then the density operator which defines the system is defined by:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = 
\backslash
sum
\backslash
limits_n W_{n}|
\backslash
psi_{n}
\backslash
rangle
\backslash
langle
\backslash
psi_{n}|$
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Note that the states 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}
\backslash
rangle$
\end_layout

\end_inset

 need not be orthogonal.
 In a discrete basis with basis set 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
phi_{1}
\backslash
rangle$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
phi_{2}
\backslash
rangle$
\end_layout

\end_inset

, ...,
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
phi_{m}
\backslash
rangle$
\end_layout

\end_inset

, we can define 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a_{i}^{n} = 
\backslash
langle
\backslash
phi_{i}|
\backslash
psi_{n}
\backslash
rangle$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a_{j}^{n} = 
\backslash
langle
\backslash
phi_{j}|
\backslash
psi_{n}
\backslash
rangle$
\end_layout

\end_inset

.
 The density operator takes the form of a matrix where the i-th and j-th
 matrix element is determined by the equation:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
langle
\backslash
phi_{i}|
\backslash
rho|
\backslash
phi_{j}
\backslash
rangle = 
\backslash
sum
\backslash
limits_n W_{n} a_{i}^{n} a_{j}^{n*}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(Blum, page 43)
\end_layout

\begin_layout Subsection
Density Operators in SymPy
\end_layout

\begin_layout Standard
In SymPy, the density operator is implemented using the class 
\family typewriter
Density
\family default
, a subclass of 
\family typewriter
QExpr
\family default
.
 The Density class provides some functionality for any quantum mechanical
 system, but has some extra features which only work for Qubit objects.
 
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/density1.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
We form a 
\family typewriter
Density
\family default
 object made up of general ket states.
 The constructor for 
\family typewriter
Density
\family default
 takes in a sequence of lists containing a state with its associated statistical
 weight.
 We then represent the density matrix using the 
\family typewriter
represent
\family default
 function which takes in the same arguments as before.
 The 
\family typewriter
matrix_to_density
\family default
 function takes in a matrix representation of a density operator and returns
 the Dirac notation representation (more on how this is done can be found
 in the next section).
 
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/density2.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
We use the same set of functions on a mixed state as we did on the pure
 state.
 The Density matrix has an 'operate_on' method which applies a sequence
 of gates to the density operator.
 
\end_layout

\begin_layout Subsection
Matrix to Dirac Notation for a Density Operator
\end_layout

\begin_layout Standard
As seen in the previous segment of code, it is possible to take in a density
 matrix which represents the state of a system and determine a representation
 as a series of outer products of states using the eigenvalues and eigenvectors
 of the matrix.
 For a density matrix, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

, with eigenvalues 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda_{n}$
\end_layout

\end_inset

 and associated eigenvectors 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi_{n}
\backslash
rangle$
\end_layout

\end_inset

, the matrix can be represented as
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = 
\backslash
sum
\backslash
limits_n 
\backslash
lambda_{n} |
\backslash
psi_{n}
\backslash
rangle
\backslash
langle
\backslash
psi_{n}|$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For a non-pure state the Dirac notation representation is not unique, so
 the returned result might not be the same set of states as one may expect.
 In SymPy, this is implemented in a separate function 
\begin_inset Quotes eld
\end_inset

matrix_to_density
\begin_inset Quotes erd
\end_inset

.
 So far, this function only works on Density matrices composed of qubits,
 but the mathematics described for doing this is general for any discrete
 system.
\end_layout

\begin_layout Subsection
Von Neumann Entropy
\end_layout

\begin_layout Standard
An important concept which can be easily determined from the density operator
 formalism is the entropy of a system.
 In rough terms, the entropy of a system measures the amount of uncertainty
 we have about what state the system is in.
 
\end_layout

\begin_layout Standard
The entropy of a system can be determined by taking the eigenvalues 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda_{n}$
\end_layout

\end_inset

 of the density operator 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

 and preforming the operation:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$S = -
\backslash
sum
\backslash
limits_n 
\backslash
lambda_{n} log(
\backslash
lambda_{n})$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is easy to show (see appendix) that when the system is in a pure state,
 the only non-zero eigenvalue of the density matrix is 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
lambda = 1$
\end_layout

\end_inset

.
 Plugging this eigenvalue into our equation for the Von Neumann entropy,
 we see that a pure state has zero entropy.
 This matches with our intuition as a perfectly well known system (a pure
 state) should not have any entropy.
\end_layout

\begin_layout Standard
In SymPy, the Von Neumann entropy is implemented for discrete systems using
 a method within the Density class.
 This method determines the eigenvalues of the density matrix by representing
 the operator as a matrix and making calls to the SymPy function which determine
s eigenvalues.
 The eigenvalues are then plugged into the equation for the Von Neumann
 entropy.
 This can be seen in the following code example:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/entropy1.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
In the above example, we calculate the entropy for both a pure and mixed
 state system using the density operator's entropy method.
 The pure state system has zero entropy and the mixed state has non-zero
 entropy as expected.
\end_layout

\begin_layout Standard
A student of classical statistical mechanics would no doubt be aware of
 the Louisville theorem which establishes that any system evolving under
 a linear Hamiltonian will maintain the same area of uncertainty in phase
 space.
 There is an equivalent form of this theorem for density operators which
 states that the uncertainty about the state of the system remains the same
 when evolving under unitary transformations.
 In other words, a pure state remains pure and a mixed state doesn't become
 any more or less mixed as it is operated on.
 One way this mathematically manifests itself is that the entropy of a state
 remains the same under unitary evolution.
 Unitary operations are isentropic.
 This is seen below:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/entropy2.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
We can see that the entropy has remained the same after applying gates to
 a state.
\end_layout

\begin_layout Subsection
The Reduced Density Matrix
\end_layout

\begin_layout Standard
Any student of quantum mechanics is aware of the definition of an entangled
 state as a state for which the constituent subsystems cannot be factored
 out.
 That is a state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
Psi
\backslash
rangle$
\end_layout

\end_inset

 with constituent systems 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
theta
\backslash
rangle$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
phi
\backslash
rangle$
\end_layout

\end_inset

 is entangled (inseparable) if and only if it is impossible to write 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi
\backslash
rangle = |
\backslash
phi
\backslash
rangle
\backslash
otimes|
\backslash
theta
\backslash
rangle$
\end_layout

\end_inset

.
 If this condition is not met, then the system is said to be in a inseparable
 or entangled state.
 For this entangled state, it is impossible to describe the entangled subsystem
 on its own without the loss of information.
 If however we wish to provide a statistical account of the state of a subsystem
, the density operator provides a useful framework in the form of an object
 called the reduced density matrix.
\end_layout

\begin_layout Standard
Consider the arbitrary state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
Phi
\backslash
rangle$
\end_layout

\end_inset

 with subsystems 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
phi
\backslash
rangle$
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
theta
\backslash
rangle$
\end_layout

\end_inset

.
 Now, say that we only really care about the state of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$| 
\backslash
phi
\backslash
rangle$
\end_layout

\end_inset

.
 We can describe the state of the subsystem by the reduced density 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho_{r}$
\end_layout

\end_inset

, where the elements of the matrix are determined by
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$ 
\backslash
langle
\backslash
theta
\backslash
phi_{j}|
\backslash
rho_{r}|
\backslash
theta
\backslash
phi_{j'}
\backslash
rangle = 
\backslash
sum
\backslash
limits_i
\backslash
langle
\backslash
theta_{i}
\backslash
phi_{j}|
\backslash
rho_{r}|
\backslash
theta_{i} 
\backslash
phi_{j'}
\backslash
rangle $
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\noindent
\align left
Alternatively, we can describe the reduced density matrix in term of something
 called a partial trace 
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho_{r} = tr_{
\backslash
phi} |
\backslash
Phi
\backslash
rangle
\backslash
langle
\backslash
Phi| $
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The sum describing the reduced density matrix is doubtlessly a pain to calculate
 (determining the reduced density matrix for even a Bell state requires
 the addition of eight numbers, and it grows exponentially in the number
 of qubits).
 Fortunately, I have added code to the density operator module which can
 calculate the reduced density matrix of a tensor product of two-state systems
 (i.e.
 qubits) by specifying which bits are to be considered the unobserved bits
 (This method could be generalized for any discrete basis, but it would
 be more difficult to code as I could not exploit bit twiddling in the implement
ation).
 This can be seen below:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/Reduced_density_matrix.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
The operation seen above is interesting in that we went irreversibly from
 a pure entangled Bell state with zero entropy to a mixed state with non-zero
 entropy.
 In this way, the partial trace of an entangled state can be thought of
 as us 'forgetting' information about one of the qubits and thus increasing
 the entropy.
 This will generally occur whenever a partial trace is preformed on two
 entangled states.
 It is thus apparent that the Louisville theorem discussed in the previous
 section does not generally apply to the partial trace operation as entropy
 is not conserved.
 
\end_layout

\begin_layout Standard
This shows us that a pure entangled state can appear to be a mixed unentangled
 state when we do not have information about one of the entangled systems.
 This concept sets up the framework for our understanding of decoherence.
 Decoherence is what occurs when a quantum superposition interacts with
 (and becomes entangled with) an unknown environment; this entanglement
 results in what appears to be the non-unitary transformation of quantum
 superpositions into classical mixtures.
 Mathematically, this manifests itself as a spontaneous diagonalization
 of the density matrix.
 Decoherence forms the classical/quantum barrier as this is where the weird
 effects of superposition and interference come to die.
 (the reader should note that coherence theory does not by itself solve
 the so called 'measurement problem' of quantum mechanics because measurement
 results in a definite state rather than a mixed state; we are still left
 with the question of why and when the quantum state collapsed into a pure
 definite state.
 For one interpretation of decoherence see Rolland Omnes, The Interpretation
 of Quantum Mechanics).
 
\end_layout

\begin_layout Subsection
Entropy of Entanglement
\end_layout

\begin_layout Standard
A wise and observant reader may have noticed that there is a very strong
 correlation between the entropy of the reduced density matrix and the entanglem
ent of the system.
 After all, the maximally entangled Bell state also produced a mixed state
 of maximal entropy under the partial trace operation.
 This observation leads to the definition of an entanglement measure called
 the 'entropy of entanglement'.
 This measure defines the entanglement of two subsystems of the state
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
Psi
\backslash
rangle$
\end_layout

\end_inset

, A and B, to be the entropy of the partial trace of the system.
 Thus:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$Entanglement(|
\backslash
Psi
\backslash
rangle) = S(tr_{A} |
\backslash
Psi
\backslash
rangle
\backslash
langle
\backslash
Psi|) = S(tr_{B} |
\backslash
Psi
\backslash
rangle
\backslash
langle
\backslash
Psi|) $
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have thus added a small bit of functionality to the code which determines
 the entropy of entanglement between any specified qubit and the system
 as a whole.
 This is seen below:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Graphics
	filename Pictures/Entropy_of_entanglement.png
	width 6in

\end_inset


\end_layout

\begin_layout Standard
The input arguments to the 
\family typewriter
entropy_of_entanglement
\family default
 are the same as those used for the 
\family typewriter
reduced_density
\family default
 function.
 We can see that the entropy of entanglement for the Bell state is .69.
 Right now, the code only allows for the calculation of the entanglement
 for a two state system, but there is no fundamental reason that this could
 not be done for any discrete system.
 
\end_layout

\begin_layout Section
Conclusions and Future Directions
\end_layout

\begin_layout Standard
SymPy's quantum code base so far has built into it a notion of Dirac notation,
 the gate model of quantum computation, and the density matrix.
 The quantum computational module has all of the structures important to
 the gate model of quantum computation, and as such can simulate quantum
 algorithms.
 The density matrix object has the capability to be represented, acted upon
 by operators, determine the entropy of a state, and determine the entropy
 of entanglement.
 In this way, the code is quite capable of modeling a wide range of systems.
\end_layout

\begin_layout Standard
We can see from the examples that the code greatly eases the algebraic and
 arithmetic difficulty in simulating quantum mechanical systems.
 The code therefore could be used as a very powerful teaching and research
 tool.
 The added code doubtlessly has potential for modeling certain quantum phenomena.
 However, because the code is in its infancy, very few simulations of physical
 systems have been written using this framework.
 When more examples using this code are written, the module will be of great
 use for teaching quantum mechanics and quantum information concepts.
 Additionally, researchers will be able to simulate quantum phenomena where
 symbolic manipulations are necessary.
 In this way, the tool will be useful for both educators and researchers.
 
\end_layout

\begin_layout Bibliography
\start_of_appendix
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

Blum, Karl.
 Density Matrix Theory and Applications.
 Plenum Press, New York, 1996.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset


\begin_inset Quotes erd
\end_inset

Entropy of Entanglement
\begin_inset Quotes erd
\end_inset

, Quantiki.
 Web.
 Accessed 1 Jun 2011.
 http://www.quantiki.org/wiki/Entropy_of_entanglement.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

Nielsen, Micheal.
 Chuang, Isaac.
 Quantum Computation and Quantum Information.
 Cambridge University Press, New York, 1996.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

 Mermin, David.
 Quantum Computer Science.
 Cambridge University Press, New York, 2007.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

 Omnes, Rolland.
 The Interpretation of Quantum Mechanics.
 Princeton University Press, New Jersey, 1994.
\end_layout

\begin_layout Standard
Further information and downloads for SymPy can be found at SymPy.org
\end_layout

\begin_layout Subsection*
Appendix A
\end_layout

\begin_layout Standard
Simple proof that 1 is the only non-zero eigenvalue for a pure state:
\end_layout

\begin_layout Standard
Suppose we have a generic pure state density matrix defined by 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho = |
\backslash
psi
\backslash
rangle
\backslash
langle
\backslash
psi|$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The eigenvalue problem for 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho|
\backslash
phi
\backslash
rangle = 
\backslash
lambda |
\backslash
phi
\backslash
rangle$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is clear that 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
phi
\backslash
rangle = |
\backslash
psi
\backslash
rangle$
\end_layout

\end_inset

 is a solution for this eigenvector problem as 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho |
\backslash
psi
\backslash
rangle = |
\backslash
psi
\backslash
rangle 
\backslash
langle
\backslash
psi | 
\backslash
psi
\backslash
rangle = |
\backslash
psi
\backslash
rangle$
\end_layout

\end_inset

 (since the inner product 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
langle
\backslash
psi | 
\backslash
psi
\backslash
rangle = 1$
\end_layout

\end_inset

).
 Note that 1 is the eigenvalue associated with the eigenvector 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|
\backslash
psi
\backslash
rangle$
\end_layout

\end_inset

.
 Since we know that 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
sum_{n} 
\backslash
lambda_{n} = 1$
\end_layout

\end_inset

 for a normalized density matrix, the other eigenvalues must be zero.
 QED.
\end_layout

\begin_layout Subsection*
The Zen of Python
\end_layout

\begin_layout Verse
Beautiful is better than ugly.
\end_layout

\begin_layout Verse
Explicit is better than implicit.
\end_layout

\begin_layout Verse
Simple is better than complex.
\end_layout

\begin_layout Verse
Complex is better than complicated.
\end_layout

\begin_layout Verse
Flat is better than nested.
\end_layout

\begin_layout Verse
Sparse is better than dense.
 
\end_layout

\begin_layout Verse
Readability counts.
\end_layout

\begin_layout Verse
Special cases aren't special enough to break the rules.
\end_layout

\begin_layout Verse
Although practicality beats purity.
 
\end_layout

\begin_layout Verse
Errors should never pass silently.
 Unless explicitly silenced.
\end_layout

\begin_layout Verse
In the face of ambiguity, refuse the temptation to guess.
\end_layout

\begin_layout Verse
There should be one-- and preferably only one --obvious way to do it.
\end_layout

\begin_layout Verse
Although that way may not be obvious at first unless you're Dutch.
 
\end_layout

\begin_layout Verse
Now is better than never.
 
\end_layout

\begin_layout Verse
Although never is often better than *right* now.
\end_layout

\begin_layout Verse
If the implementation is hard to explain, it's a bad idea.
 
\end_layout

\begin_layout Verse
If the implementation is easy to explain, it may be a good idea.
 
\end_layout

\begin_layout Verse
Namespaces are one honking great idea -- let's do more of those!
\end_layout

\begin_layout Verse
--The Zen of Python
\end_layout

\end_body
\end_document
